!function (t) { t.color = {}, t.color.make = function (i, e, o, n) { var r = {}; return r.r = i || 0, r.g = e || 0, r.b = o || 0, r.a = null != n ? n : 1, r.add = function (t, i) { for (var e = 0; e < t.length; ++e)r[t.charAt(e)] += i; return r.normalize() }, r.scale = function (t, i) { for (var e = 0; e < t.length; ++e)r[t.charAt(e)] *= i; return r.normalize() }, r.toString = function () { return r.a >= 1 ? "rgb(" + [r.r, r.g, r.b].join(",") + ")" : "rgba(" + [r.r, r.g, r.b, r.a].join(",") + ")" }, r.normalize = function () { function t(t, i, e) { return i < t ? t : i > e ? e : i } return r.r = t(0, parseInt(r.r), 255), r.g = t(0, parseInt(r.g), 255), r.b = t(0, parseInt(r.b), 255), r.a = t(0, r.a, 1), r }, r.clone = function () { return t.color.make(r.r, r.b, r.g, r.a) }, r.normalize() }, t.color.extract = function (i, e) { var o; do { if ("" != (o = i.css(e).toLowerCase()) && "transparent" != o) break; i = i.parent() } while (i.length && !t.nodeName(i.get(0), "body")); return "rgba(0, 0, 0, 0)" == o && (o = "transparent"), t.color.parse(o) }, t.color.parse = function (e) { var o, n = t.color.make; if (o = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(e)) return n(parseInt(o[1], 10), parseInt(o[2], 10), parseInt(o[3], 10)); if (o = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(e)) return n(parseInt(o[1], 10), parseInt(o[2], 10), parseInt(o[3], 10), parseFloat(o[4])); if (o = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(e)) return n(2.55 * parseFloat(o[1]), 2.55 * parseFloat(o[2]), 2.55 * parseFloat(o[3])); if (o = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(e)) return n(2.55 * parseFloat(o[1]), 2.55 * parseFloat(o[2]), 2.55 * parseFloat(o[3]), parseFloat(o[4])); if (o = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(e)) return n(parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)); if (o = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(e)) return n(parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)); var r = t.trim(e).toLowerCase(); return "transparent" == r ? n(255, 255, 255, 0) : n((o = i[r] || [0, 0, 0])[0], o[1], o[2]) }; var i = { aqua: [0, 255, 255], azure: [240, 255, 255], beige: [245, 245, 220], black: [0, 0, 0], blue: [0, 0, 255], brown: [165, 42, 42], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgrey: [169, 169, 169], darkgreen: [0, 100, 0], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkviolet: [148, 0, 211], fuchsia: [255, 0, 255], gold: [255, 215, 0], green: [0, 128, 0], indigo: [75, 0, 130], khaki: [240, 230, 140], lightblue: [173, 216, 230], lightcyan: [224, 255, 255], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightyellow: [255, 255, 224], lime: [0, 255, 0], magenta: [255, 0, 255], maroon: [128, 0, 0], navy: [0, 0, 128], olive: [128, 128, 0], orange: [255, 165, 0], pink: [255, 192, 203], purple: [128, 0, 128], violet: [128, 0, 128], red: [255, 0, 0], silver: [192, 192, 192], white: [255, 255, 255], yellow: [255, 255, 0] } }(jQuery), function (t) { var i = Object.prototype.hasOwnProperty; function e(i, e) { var o = e.children("." + i)[0]; if (null == o && ((o = document.createElement("canvas")).className = i, t(o).css({ direction: "ltr", position: "absolute", left: 0, top: 0 }).appendTo(e), !o.getContext)) { if (window.G_vmlCanvasManager) o = window.G_vmlCanvasManager.initElement(o); else throw Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.") } this.element = o; var n = this.context = o.getContext("2d"), r = window.devicePixelRatio || 1, l = n.webkitBackingStorePixelRatio || n.mozBackingStorePixelRatio || n.msBackingStorePixelRatio || n.oBackingStorePixelRatio || n.backingStorePixelRatio || 1; this.pixelRatio = r / l, this.resize(e.width(), e.height()), this.textContainer = null, this.text = {}, this._textCache = {} } function o(i, o, n, r) { var l, a = [], s = { colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"], legend: { show: !0, noColumns: 1, labelFormatter: null, labelBoxBorderColor: "#ccc", container: null, position: "ne", margin: 5, backgroundColor: null, backgroundOpacity: .85, sorted: null }, xaxis: { show: null, position: "bottom", mode: null, font: null, color: null, tickColor: null, transform: null, inverseTransform: null, min: null, max: null, autoscaleMargin: null, ticks: null, tickFormatter: null, labelWidth: null, labelHeight: null, reserveSpace: null, tickLength: null, alignTicksWithAxis: null, tickDecimals: null, tickSize: null, minTickSize: null }, yaxis: { autoscaleMargin: .02, position: "left" }, xaxes: [], yaxes: [], series: { points: { show: !1, radius: 3, lineWidth: 2, fill: !0, fillColor: "#ffffff", symbol: "circle" }, lines: { lineWidth: 2, fill: !1, fillColor: null, steps: !1 }, bars: { show: !1, lineWidth: 2, barWidth: 1, fill: !0, fillColor: null, align: "left", horizontal: !1, zero: !0 }, shadowSize: 3, highlightColor: null }, grid: { show: !0, aboveData: !1, color: "#545454", backgroundColor: null, borderColor: null, tickColor: null, margin: 0, labelMargin: 5, axisMargin: 8, borderWidth: 2, minBorderMargin: null, markings: null, markingsColor: "#f4f4f4", markingsLineWidth: 2, clickable: !1, hoverable: !1, autoHighlight: !0, mouseActiveRadius: 10 }, interaction: { redrawOverlayInterval: 1e3 / 60 }, hooks: {} }, c = null, f = null, u = null, h = null, d = null, p = [], m = [], x = { left: 0, right: 0, top: 0, bottom: 0 }, g = 0, $ = 0, b = { processOptions: [], processRawData: [], processDatapoints: [], processOffset: [], drawBackground: [], drawSeries: [], draw: [], bindEvents: [], drawOverlay: [], shutdown: [] }, v = this; function _(t, i) { i = [v].concat(i); for (var e = 0; e < t.length; ++e)t[e].apply(this, i) } function k(i) { a = function i(e) { for (var o = [], n = 0; n < e.length; ++n) { var r = t.extend(!0, {}, s.series); null != e[n].data ? (r.data = e[n].data, delete e[n].data, t.extend(!0, r, e[n]), e[n].data = r.data) : r.data = e[n], o.push(r) } return o }(i), function i() { var e, o = a.length, n = -1; for (e = 0; e < a.length; ++e) { var r = a[e].color; null != r && (o--, "number" == typeof r && r > n && (n = r)) } o <= n && (o = n + 1); var l, c = [], f = s.colors, u = f.length, h = 0; for (e = 0; e < o; e++)l = t.color.parse(f[e % u] || "#666"), e % u == 0 && e && (h = h >= 0 ? h < .5 ? -h - .2 : 0 : -h), c[e] = l.scale("rgb", 1 + h); var d, x = 0; for (e = 0; e < a.length; ++e) { if (null == (d = a[e]).color ? (d.color = c[x].toString(), ++x) : "number" == typeof d.color && (d.color = c[d.color].toString()), null == d.lines.show) { var g, $ = !0; for (g in d) if (d[g] && d[g].show) { $ = !1; break } $ && (d.lines.show = !0) } null == d.lines.zero && (d.lines.zero = !!d.lines.fill), d.xaxis = T(p, y(d, "x")), d.yaxis = T(m, y(d, "y")) } }(), function i() { var e, o, n, r, l, s, c, f, u, h, d, p, m = Number.POSITIVE_INFINITY, x = Number.NEGATIVE_INFINITY, g = Number.MAX_VALUE; function $(t, i, e) { i < t.datamin && i != -g && (t.datamin = i), e > t.datamax && e != g && (t.datamax = e) } for (t.each(w(), function (t, i) { i.datamin = m, i.datamax = x, i.used = !1 }), e = 0; e < a.length; ++e)(l = a[e]).datapoints = { points: [] }, _(b.processRawData, [l, l.data, l.datapoints]); for (e = 0; e < a.length; ++e) { if (d = (l = a[e]).data, !(p = l.datapoints.format)) { if ((p = []).push({ x: !0, number: !0, required: !0 }), p.push({ y: !0, number: !0, required: !0 }), l.bars.show || l.lines.show && l.lines.fill) { var v = !!(l.bars.show && l.bars.zero || l.lines.show && l.lines.zero); p.push({ y: !0, number: !0, required: !1, defaultValue: 0, autoscale: v }), l.bars.horizontal && (delete p[p.length - 1].y, p[p.length - 1].x = !0) } l.datapoints.format = p } if (null == l.datapoints.pointsize) { l.datapoints.pointsize = p.length, c = l.datapoints.pointsize, s = l.datapoints.points; var k = l.lines.show && l.lines.steps; for (l.xaxis.used = l.yaxis.used = !0, o = n = 0; o < d.length; ++o, n += c) { var y = null == (h = d[o]); if (!y) for (r = 0; r < c; ++r)f = h[r], (u = p[r]) && (u.number && null != f && (isNaN(f = +f) ? f = null : f == 1 / 0 ? f = g : f == -1 / 0 && (f = -g)), null == f && (u.required && (y = !0), null != u.defaultValue && (f = u.defaultValue))), s[n + r] = f; if (y) for (r = 0; r < c; ++r)null != (f = s[n + r]) && !1 !== (u = p[r]).autoscale && (u.x && $(l.xaxis, f, f), u.y && $(l.yaxis, f, f)), s[n + r] = null; else if (k && n > 0 && null != s[n - c] && s[n - c] != s[n] && s[n - c + 1] != s[n + 1]) { for (r = 0; r < c; ++r)s[n + c + r] = s[n + r]; s[n + 1] = s[n - c + 1], n += c } } } } for (e = 0; e < a.length; ++e)l = a[e], _(b.processDatapoints, [l, l.datapoints]); for (e = 0; e < a.length; ++e) { s = (l = a[e]).datapoints.points, c = l.datapoints.pointsize, p = l.datapoints.format; var C, T = m, S = m, W = x, z = x; for (o = 0; o < s.length; o += c)if (null != s[o]) for (r = 0; r < c; ++r)f = s[o + r], (u = p[r]) && !1 !== u.autoscale && f != g && f != -g && (u.x && (f < T && (T = f), f > W && (W = f)), u.y && (f < S && (S = f), f > z && (z = f))); if (l.bars.show) { switch (l.bars.align) { case "left": C = 0; break; case "right": C = -l.bars.barWidth; break; default: C = -l.bars.barWidth / 2 }l.bars.horizontal ? (S += C, z += C + l.bars.barWidth) : (T += C, W += C + l.bars.barWidth) } $(l.xaxis, T, W), $(l.yaxis, S, z) } t.each(w(), function (t, i) { i.datamin == m && (i.datamin = null), i.datamax == x && (i.datamax = null) }) }() } function y(t, i) { var e = t[i + "axis"]; return "object" == typeof e && (e = e.n), "number" != typeof e && (e = 1), e } function w() { return t.grep(p.concat(m), function (t) { return t }) } function C(t) { var i, e, o = {}; for (i = 0; i < p.length; ++i)(e = p[i]) && e.used && (o["x" + e.n] = e.c2p(t.left)); for (i = 0; i < m.length; ++i)(e = m[i]) && e.used && (o["y" + e.n] = e.c2p(t.top)); return void 0 !== o.x1 && (o.x = o.x1), void 0 !== o.y1 && (o.y = o.y1), o } function T(i, e) { return i[e - 1] || (i[e - 1] = { n: e, direction: i == p ? "x" : "y", options: t.extend(!0, {}, i == p ? s.xaxis : s.yaxis) }), i[e - 1] } function S() { R && clearTimeout(R), u.unbind("mousemove", H), u.unbind("mouseleave", M), u.unbind("click", j), _(b.shutdown, [u]) } function W(i) { var e = i.labelWidth, o = i.labelHeight, n = i.options.position, r = "x" === i.direction, l = i.options.tickLength, a = s.grid.axisMargin, f = s.grid.labelMargin, u = !0, h = !0, d = !0, g = !1; t.each(r ? p : m, function (t, e) { e && (e.show || e.reserveSpace) && (e === i ? g = !0 : e.options.position === n && (g ? h = !1 : u = !1), g || (d = !1)) }), h && (a = 0), null == l && (l = d ? "full" : 5), isNaN(+l) || (f += +l), r ? (o += f, "bottom" == n ? (x.bottom += o + a, i.box = { top: c.height - x.bottom, height: o }) : (i.box = { top: x.top + a, height: o }, x.top += o + a)) : (e += f, "left" == n ? (i.box = { left: x.left + a, width: e }, x.left += e + a) : (x.right += e + a, i.box = { left: c.width - x.right, width: e })), i.position = n, i.tickLength = l, i.box.padding = f, i.innermost = u } function z() { var e, o = w(), n = s.grid.show; for (var r in x) { var l = s.grid.margin || 0; x[r] = "number" == typeof l ? l : l[r] || 0 } for (var r in _(b.processOffset, [x]), x) "object" == typeof s.grid.borderWidth ? x[r] += n ? s.grid.borderWidth[r] : 0 : x[r] += n ? s.grid.borderWidth : 0; if (t.each(o, function (t, i) { var e = i.options; i.show = null == e.show ? i.used : e.show, i.reserveSpace = null == e.reserveSpace ? i.show : e.reserveSpace, function t(i) { var e = i.options, o = +(null != e.min ? e.min : i.datamin), n = +(null != e.max ? e.max : i.datamax), r = n - o; if (0 == r) { var l = 0 == n ? 1 : .01; null == e.min && (o -= l), (null == e.max || null != e.min) && (n += l) } else { var a = e.autoscaleMargin; null != a && (null == e.min && (o -= r * a) < 0 && null != i.datamin && i.datamin >= 0 && (o = 0), null == e.max && (n += r * a) > 0 && null != i.datamax && i.datamax <= 0 && (n = 0)) } i.min = o, i.max = n }(i) }), n) { var f = t.grep(o, function (t) { return t.show || t.reserveSpace }); for (t.each(f, function (i, e) { var o, n; (function i(e) { var o = e.options; a = "number" == typeof o.ticks && o.ticks > 0 ? o.ticks : .3 * Math.sqrt("x" == e.direction ? c.width : c.height); var n = (e.max - e.min) / a, r = -Math.floor(Math.log(n) / Math.LN10), l = o.tickDecimals; null != l && r > l && (r = l); var a, s, f = Math.pow(10, -r), u = n / f; if (u < 1.5 ? s = 1 : u < 3 ? (s = 2, u > 2.25 && (null == l || r + 1 <= l) && (s = 2.5, ++r)) : s = u < 7.5 ? 5 : 10, s *= f, null != o.minTickSize && s < o.minTickSize && (s = o.minTickSize), e.delta = n, e.tickDecimals = Math.max(0, null != l ? l : r), e.tickSize = o.tickSize || s, "time" == o.mode && !e.tickGenerator) throw Error("Time mode requires the flot.time plugin."); if (e.tickGenerator || (e.tickGenerator = function (t) { var i, e, o, n = [], r = (i = t.min, e = t.tickSize, e * Math.floor(i / e)), l = 0, a = Number.NaN; do o = a, a = r + l * t.tickSize, n.push(a), ++l; while (a < t.max && a != o); return n }, e.tickFormatter = function (t, i) { var e = i.tickDecimals ? Math.pow(10, i.tickDecimals) : 1, o = "" + Math.round(t * e) / e; if (null != i.tickDecimals) { var n = o.indexOf("."), r = -1 == n ? 0 : o.length - n - 1; if (r < i.tickDecimals) return (r ? o : o + ".") + ("" + e).substr(1, i.tickDecimals - r) } return o }), t.isFunction(o.tickFormatter) && (e.tickFormatter = function (t, i) { return "" + o.tickFormatter(t, i) }), null != o.alignTicksWithAxis) { var h = ("x" == e.direction ? p : m)[o.alignTicksWithAxis - 1]; if (h && h.used && h != e) { var d = e.tickGenerator(e); if (d.length > 0 && (null == o.min && (e.min = Math.min(e.min, d[0])), null == o.max && d.length > 1 && (e.max = Math.max(e.max, d[d.length - 1]))), e.tickGenerator = function (t) { var i, e, o = []; for (e = 0; e < h.ticks.length; ++e)i = (h.ticks[e].v - h.min) / (h.max - h.min), i = t.min + i * (t.max - t.min), o.push(i); return o }, !e.mode && null == o.tickDecimals) { var x = Math.max(0, -Math.floor(Math.log(e.delta) / Math.LN10) + 1), g = e.tickGenerator(e); g.length > 1 && /\..*0$/.test((g[1] - g[0]).toFixed(x)) || (e.tickDecimals = x) } } } })(e), function i(e) { var o, n, r = e.options.ticks, l = []; for (null == r || "number" == typeof r && r > 0 ? l = e.tickGenerator(e) : r && (l = t.isFunction(r) ? r(e) : r), e.ticks = [], o = 0; o < l.length; ++o) { var a = null, s = l[o]; "object" == typeof s ? (n = +s[0], s.length > 1 && (a = s[1])) : n = +s, null == a && (a = e.tickFormatter(n, e)), isNaN(n) || e.ticks.push({ v: n, label: a }) } }(e), o = e, n = e.ticks, o.options.autoscaleMargin && n.length > 0 && (null == o.options.min && (o.min = Math.min(o.min, n[0].v)), null == o.options.max && n.length > 1 && (o.max = Math.max(o.max, n[n.length - 1].v))), function t(i) { for (var e = i.options, o = i.ticks || [], n = e.labelWidth || 0, r = e.labelHeight || 0, l = n || ("x" == i.direction ? Math.floor(c.width / (o.length || 1)) : null), a = i.direction + "Axis " + i.direction + i.n + "Axis", s = "flot-" + i.direction + "-axis flot-" + i.direction + i.n + "-axis " + a, f = e.font || "flot-tick-label tickLabel", u = 0; u < o.length; ++u) { var h = o[u]; if (h.label) { var d = c.getTextInfo(s, h.label, f, null, l); n = Math.max(n, d.width), r = Math.max(r, d.height) } } i.labelWidth = e.labelWidth || n, i.labelHeight = e.labelHeight || r }(e) }), e = f.length - 1; e >= 0; --e)W(f[e]); (function i() { var e, o = s.grid.minBorderMargin; if (null == o) for (e = 0, o = 0; e < a.length; ++e)o = Math.max(o, 2 * (a[e].points.radius + a[e].points.lineWidth / 2)); var n = { left: o, right: o, top: o, bottom: o }; t.each(w(), function (t, i) { i.reserveSpace && i.ticks && i.ticks.length && ("x" === i.direction ? (n.left = Math.max(n.left, i.labelWidth / 2), n.right = Math.max(n.right, i.labelWidth / 2)) : (n.bottom = Math.max(n.bottom, i.labelHeight / 2), n.top = Math.max(n.top, i.labelHeight / 2))) }), x.left = Math.ceil(Math.max(n.left, x.left)), x.right = Math.ceil(Math.max(n.right, x.right)), x.top = Math.ceil(Math.max(n.top, x.top)), x.bottom = Math.ceil(Math.max(n.bottom, x.bottom)) })(), t.each(f, function (t, i) { var e; "x" == (e = i).direction ? (e.box.left = x.left - e.labelWidth / 2, e.box.width = c.width - x.left - x.right + e.labelWidth) : (e.box.top = x.top - e.labelHeight / 2, e.box.height = c.height - x.bottom - x.top + e.labelHeight) }) } g = c.width - x.left - x.right, $ = c.height - x.bottom - x.top, t.each(o, function (t, i) { !function t(i) { function e(t) { return t } var o, n, r = i.options.transform || e, l = i.options.inverseTransform; "x" == i.direction ? (o = i.scale = g / Math.abs(r(i.max) - r(i.min)), n = Math.min(r(i.max), r(i.min))) : (o = -(o = i.scale = $ / Math.abs(r(i.max) - r(i.min))), n = Math.max(r(i.max), r(i.min))), r == e ? i.p2c = function (t) { return (t - n) * o } : i.p2c = function (t) { return (r(t) - n) * o }, l ? i.c2p = function (t) { return l(n + t / o) } : i.c2p = function (t) { return n + t / o } }(i) }), n && t.each(w(), function (t, i) { var e, o, n, r, l, a = i.box, s = i.direction + "Axis " + i.direction + i.n + "Axis", f = "flot-" + i.direction + "-axis flot-" + i.direction + i.n + "-axis " + s, u = i.options.font || "flot-tick-label tickLabel"; if (c.removeText(f), i.show && 0 != i.ticks.length) for (var h = 0; h < i.ticks.length; ++h)!(e = i.ticks[h]).label || e.v < i.min || e.v > i.max || ("x" == i.direction ? (r = "center", o = x.left + i.p2c(e.v), "bottom" == i.position ? n = a.top + a.padding : (n = a.top + a.height - a.padding, l = "bottom")) : (l = "middle", n = x.top + i.p2c(e.v), "left" == i.position ? (o = a.left + a.width - a.padding, r = "right") : o = a.left + a.padding), c.addText(f, o, n, e.label, u, null, null, r, l)) }), function e() { if (null != s.legend.container ? t(s.legend.container).html("") : i.find(".legend").remove(), s.legend.show) { for (var o, n, r = [], l = [], c = !1, f = s.legend.labelFormatter, u = 0; u < a.length; ++u)(o = a[u]).label && (n = f ? f(o.label, o) : o.label) && l.push({ label: n, color: o.color }); if (s.legend.sorted) { if (t.isFunction(s.legend.sorted)) l.sort(s.legend.sorted); else if ("reverse" == s.legend.sorted) l.reverse(); else { var h = "descending" != s.legend.sorted; l.sort(function (t, i) { return t.label == i.label ? 0 : t.label < i.label != h ? 1 : -1 }) } } for (var u = 0; u < l.length; ++u) { var d = l[u]; u % s.legend.noColumns == 0 && (c && r.push("</tr>"), r.push("<tr>"), c = !0), r.push('<td class="legendColorBox"><div style="border:1px solid ' + s.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + d.color + ';overflow:hidden"></div></div></td><td class="legendLabel">' + d.label + "</td>") } if (c && r.push("</tr>"), 0 != r.length) { var p = '<table style="font-size:smaller;color:' + s.grid.color + '">' + r.join("") + "</table>"; if (null != s.legend.container) t(s.legend.container).html(p); else { var m = "", g = s.legend.position, $ = s.legend.margin; null == $[0] && ($ = [$, $]), "n" == g.charAt(0) ? m += "top:" + ($[1] + x.top) + "px;" : "s" == g.charAt(0) && (m += "bottom:" + ($[1] + x.bottom) + "px;"), "e" == g.charAt(1) ? m += "right:" + ($[0] + x.right) + "px;" : "w" == g.charAt(1) && (m += "left:" + ($[0] + x.left) + "px;"); var b = t('<div class="legend">' + p.replace('style="', 'style="position:absolute;' + m + ";") + "</div>").appendTo(i); if (0 != s.legend.backgroundOpacity) { var v = s.legend.backgroundColor; null == v && ((v = (v = s.grid.backgroundColor) && "string" == typeof v ? t.color.parse(v) : t.color.extract(b, "background-color")).a = 1, v = v.toString()); var _ = b.children(); t('<div style="position:absolute;width:' + _.width() + "px;height:" + _.height() + "px;" + m + "background-color:" + v + ';"> </div>').prependTo(b).css("opacity", s.legend.backgroundOpacity) } } } } }() } function A() { c.clear(), _(b.drawBackground, [h]); var t = s.grid; t.show && t.backgroundColor && (h.save(), h.translate(x.left, x.top), h.fillStyle = U(s.grid.backgroundColor, $, 0, "rgba(255, 255, 255, 0)"), h.fillRect(0, 0, g, $), h.restore()), t.show && !t.aboveData && I(); for (var i = 0; i < a.length; ++i)_(b.drawSeries, [h, a[i]]), D(a[i]); _(b.draw, [h]), t.show && t.aboveData && I(), c.render(), E() } function P(t, i) { for (var e, o, n, r, l = w(), a = 0; a < l.length; ++a)if ((e = l[a]).direction == i && (t[r = i + e.n + "axis"] || 1 != e.n || (r = i + "axis"), t[r])) { o = t[r].from, n = t[r].to; break } if (t[r] || (e = "x" == i ? p[0] : m[0], o = t[i + "1"], n = t[i + "2"]), null != o && null != n && o > n) { var s = o; o = n, n = s } return { from: o, to: n, axis: e } } function I() { h.save(), h.translate(x.left, x.top); var i = s.grid.markings; if (i) for (t.isFunction(i) && ((d = v.getAxes()).xmin = d.xaxis.min, d.xmax = d.xaxis.max, d.ymin = d.yaxis.min, d.ymax = d.yaxis.max, i = i(d)), u = 0; u < i.length; ++u) { var e = i[u], o = P(e, "x"), n = P(e, "y"); if (null == o.from && (o.from = o.axis.min), null == o.to && (o.to = o.axis.max), null == n.from && (n.from = n.axis.min), null == n.to && (n.to = n.axis.max), !(o.to < o.axis.min) && !(o.from > o.axis.max) && !(n.to < n.axis.min) && !(n.from > n.axis.max)) { o.from = Math.max(o.from, o.axis.min), o.to = Math.min(o.to, o.axis.max), n.from = Math.max(n.from, n.axis.min), n.to = Math.min(n.to, n.axis.max); var r = o.from === o.to, l = n.from === n.to; if (r && l) continue; if (o.from = Math.floor(o.axis.p2c(o.from)), o.to = Math.floor(o.axis.p2c(o.to)), n.from = Math.floor(n.axis.p2c(n.from)), n.to = Math.floor(n.axis.p2c(n.to)), r || l) { var a = e.lineWidth || s.grid.markingsLineWidth, c = a % 2 ? .5 : 0; h.beginPath(), h.strokeStyle = e.color || s.grid.markingsColor, h.lineWidth = a, r ? (h.moveTo(o.to + c, n.from), h.lineTo(o.to + c, n.to)) : (h.moveTo(o.from, n.to + c), h.lineTo(o.to, n.to + c)), h.stroke() } else h.fillStyle = e.color || s.grid.markingsColor, h.fillRect(o.from, n.to, o.to - o.from, n.from - n.to) } } d = w(), p = s.grid.borderWidth; for (var f = 0; f < d.length; ++f) { var u, d, p, m, b, _, k, y, C = d[f], T = C.box, S = C.tickLength; if (C.show && 0 != C.ticks.length) { for (h.lineWidth = 1, "x" == C.direction ? (b = 0, _ = "full" == S ? "top" == C.position ? 0 : $ : T.top - x.top + ("top" == C.position ? T.height : 0)) : (_ = 0, b = "full" == S ? "left" == C.position ? 0 : g : T.left - x.left + ("left" == C.position ? T.width : 0)), C.innermost || (h.strokeStyle = C.options.color, h.beginPath(), k = y = 0, "x" == C.direction ? k = g + 1 : y = $ + 1, 1 == h.lineWidth && ("x" == C.direction ? _ = Math.floor(_) + .5 : b = Math.floor(b) + .5), h.moveTo(b, _), h.lineTo(b + k, _ + y), h.stroke()), h.strokeStyle = C.options.tickColor, h.beginPath(), u = 0; u < C.ticks.length; ++u) { var W = C.ticks[u].v; k = y = 0, isNaN(W) || W < C.min || W > C.max || "full" == S && ("object" == typeof p && p[C.position] > 0 || p > 0) && (W == C.min || W == C.max) || ("x" == C.direction ? (b = C.p2c(W), y = "full" == S ? -$ : S, "top" == C.position && (y = -y)) : (_ = C.p2c(W), k = "full" == S ? -g : S, "left" == C.position && (k = -k)), 1 == h.lineWidth && ("x" == C.direction ? b = Math.floor(b) + .5 : _ = Math.floor(_) + .5), h.moveTo(b, _), h.lineTo(b + k, _ + y)) } h.stroke() } } p && (m = s.grid.borderColor, "object" == typeof p || "object" == typeof m ? ("object" != typeof p && (p = { top: p, right: p, bottom: p, left: p }), "object" != typeof m && (m = { top: m, right: m, bottom: m, left: m }), p.top > 0 && (h.strokeStyle = m.top, h.lineWidth = p.top, h.beginPath(), h.moveTo(0 - p.left, 0 - p.top / 2), h.lineTo(g, 0 - p.top / 2), h.stroke()), p.right > 0 && (h.strokeStyle = m.right, h.lineWidth = p.right, h.beginPath(), h.moveTo(g + p.right / 2, 0 - p.top), h.lineTo(g + p.right / 2, $), h.stroke()), p.bottom > 0 && (h.strokeStyle = m.bottom, h.lineWidth = p.bottom, h.beginPath(), h.moveTo(g + p.right, $ + p.bottom / 2), h.lineTo(0, $ + p.bottom / 2), h.stroke()), p.left > 0 && (h.strokeStyle = m.left, h.lineWidth = p.left, h.beginPath(), h.moveTo(0 - p.left / 2, $ + p.bottom), h.lineTo(0 - p.left / 2, 0), h.stroke())) : (h.lineWidth = p, h.strokeStyle = s.grid.borderColor, h.strokeRect(-p / 2, -p / 2, g + p, $ + p))), h.restore() } function D(t) { t.lines.show && function t(i) { function e(t, i, e, o, n) { var r = t.points, l = t.pointsize, a = null, s = null; h.beginPath(); for (var c = l; c < r.length; c += l) { var f = r[c - l], u = r[c - l + 1], d = r[c], p = r[c + 1]; if (null != f && null != d) { if (u <= p && u < n.min) { if (p < n.min) continue; f = (n.min - u) / (p - u) * (d - f) + f, u = n.min } else if (p <= u && p < n.min) { if (u < n.min) continue; d = (n.min - u) / (p - u) * (d - f) + f, p = n.min } if (u >= p && u > n.max) { if (p > n.max) continue; f = (n.max - u) / (p - u) * (d - f) + f, u = n.max } else if (p >= u && p > n.max) { if (u > n.max) continue; d = (n.max - u) / (p - u) * (d - f) + f, p = n.max } if (f <= d && f < o.min) { if (d < o.min) continue; u = (o.min - f) / (d - f) * (p - u) + u, f = o.min } else if (d <= f && d < o.min) { if (f < o.min) continue; p = (o.min - f) / (d - f) * (p - u) + u, d = o.min } if (f >= d && f > o.max) { if (d > o.max) continue; u = (o.max - f) / (d - f) * (p - u) + u, f = o.max } else if (d >= f && d > o.max) { if (f > o.max) continue; p = (o.max - f) / (d - f) * (p - u) + u, d = o.max } (f != a || u != s) && h.moveTo(o.p2c(f) + i, n.p2c(u) + e), a = d, s = p, h.lineTo(o.p2c(d) + i, n.p2c(p) + e) } } h.stroke() } h.save(), h.translate(x.left, x.top), h.lineJoin = "round"; var o = i.lines.lineWidth, n = i.shadowSize; if (o > 0 && n > 0) { h.lineWidth = n, h.strokeStyle = "rgba(0,0,0,0.1)"; var r = Math.PI / 18; e(i.datapoints, Math.sin(r) * (o / 2 + n / 2), Math.cos(r) * (o / 2 + n / 2), i.xaxis, i.yaxis), h.lineWidth = n / 2, e(i.datapoints, Math.sin(r) * (o / 2 + n / 4), Math.cos(r) * (o / 2 + n / 4), i.xaxis, i.yaxis) } h.lineWidth = o, h.strokeStyle = i.color; var l = L(i.lines, i.color, 0, $); l && (h.fillStyle = l, function t(i, e, o) { for (var n = i.points, r = i.pointsize, l = Math.min(Math.max(0, o.min), o.max), a = 0, s = !1, c = 1, f = 0, u = 0; !(r > 0) || !(a > n.length + r);) { var d = n[(a += r) - r], p = n[a - r + c], m = n[a], x = n[a + c]; if (s) { if (r > 0 && null != d && null == m) { u = a, r = -r, c = 2; continue } if (r < 0 && a == f + r) { h.fill(), s = !1, c = 1, a = f = u + (r = -r); continue } } if (null != d && null != m) { if (d <= m && d < e.min) { if (m < e.min) continue; p = (e.min - d) / (m - d) * (x - p) + p, d = e.min } else if (m <= d && m < e.min) { if (d < e.min) continue; x = (e.min - d) / (m - d) * (x - p) + p, m = e.min } if (d >= m && d > e.max) { if (m > e.max) continue; p = (e.max - d) / (m - d) * (x - p) + p, d = e.max } else if (m >= d && m > e.max) { if (d > e.max) continue; x = (e.max - d) / (m - d) * (x - p) + p, m = e.max } if (s || (h.beginPath(), h.moveTo(e.p2c(d), o.p2c(l)), s = !0), p >= o.max && x >= o.max) { h.lineTo(e.p2c(d), o.p2c(o.max)), h.lineTo(e.p2c(m), o.p2c(o.max)); continue } if (p <= o.min && x <= o.min) { h.lineTo(e.p2c(d), o.p2c(o.min)), h.lineTo(e.p2c(m), o.p2c(o.min)); continue } var g = d, $ = m; p <= x && p < o.min && x >= o.min ? (d = (o.min - p) / (x - p) * (m - d) + d, p = o.min) : x <= p && x < o.min && p >= o.min && (m = (o.min - p) / (x - p) * (m - d) + d, x = o.min), p >= x && p > o.max && x <= o.max ? (d = (o.max - p) / (x - p) * (m - d) + d, p = o.max) : x >= p && x > o.max && p <= o.max && (m = (o.max - p) / (x - p) * (m - d) + d, x = o.max), d != g && h.lineTo(e.p2c(g), o.p2c(p)), h.lineTo(e.p2c(d), o.p2c(p)), h.lineTo(e.p2c(m), o.p2c(x)), m != $ && (h.lineTo(e.p2c(m), o.p2c(x)), h.lineTo(e.p2c($), o.p2c(x))) } } }(i.datapoints, i.xaxis, i.yaxis)), o > 0 && e(i.datapoints, 0, 0, i.xaxis, i.yaxis), h.restore() }(t), t.bars.show && function t(i) { switch (h.save(), h.translate(x.left, x.top), h.lineWidth = i.bars.lineWidth, h.strokeStyle = i.color, i.bars.align) { case "left": e = 0; break; case "right": e = -i.bars.barWidth; break; default: e = -i.bars.barWidth / 2 }var e, o = i.bars.fill ? function (t, e) { return L(i.bars, i.color, t, e) } : null; (function t(e, o, n, r, l, a) { for (var s = e.points, c = e.pointsize, f = 0; f < s.length; f += c)null != s[f] && F(s[f], s[f + 1], s[f + 2], o, n, r, l, a, h, i.bars.horizontal, i.bars.lineWidth) })(i.datapoints, e, e + i.bars.barWidth, o, i.xaxis, i.yaxis), h.restore() }(t), t.points.show && function t(i) { function e(t, i, e, o, n, r, l, a) { for (var s = t.points, c = t.pointsize, f = 0; f < s.length; f += c) { var u = s[f], d = s[f + 1]; null == u || u < r.min || u > r.max || d < l.min || d > l.max || (h.beginPath(), u = r.p2c(u), d = l.p2c(d) + o, "circle" == a ? h.arc(u, d, i, 0, n ? Math.PI : 2 * Math.PI, !1) : a(h, u, d, i, n), h.closePath(), e && (h.fillStyle = e, h.fill()), h.stroke()) } } h.save(), h.translate(x.left, x.top); var o = i.points.lineWidth, n = i.shadowSize, r = i.points.radius, l = i.points.symbol; if (0 == o && (o = 1e-4), o > 0 && n > 0) { var a = n / 2; h.lineWidth = a, h.strokeStyle = "rgba(0,0,0,0.1)", e(i.datapoints, r, null, a + a / 2, !0, i.xaxis, i.yaxis, l), h.strokeStyle = "rgba(0,0,0,0.2)", e(i.datapoints, r, null, a / 2, !0, i.xaxis, i.yaxis, l) } h.lineWidth = o, h.strokeStyle = i.color, e(i.datapoints, r, L(i.points, i.color), 0, !1, i.xaxis, i.yaxis, l), h.restore() }(t) } function F(t, i, e, o, n, r, l, a, s, c, f) { var u, h, d, p, m, x, g, $, b; c ? ($ = x = g = !0, m = !1, u = e, h = t, p = i + o, d = i + n, h < u && (b = h, h = u, u = b, m = !0, x = !1)) : (m = x = g = !0, $ = !1, u = t + o, h = t + n, d = e, (p = i) < d && (b = p, p = d, d = b, $ = !0, g = !1)), !(h < l.min) && !(u > l.max) && !(p < a.min) && !(d > a.max) && (u < l.min && (u = l.min, m = !1), h > l.max && (h = l.max, x = !1), d < a.min && (d = a.min, $ = !1), p > a.max && (p = a.max, g = !1), u = l.p2c(u), d = a.p2c(d), h = l.p2c(h), p = a.p2c(p), r && (s.fillStyle = r(d, p), s.fillRect(u, p, h - u, d - p)), f > 0 && (m || x || g || $) && (s.beginPath(), s.moveTo(u, d), m ? s.lineTo(u, p) : s.moveTo(u, p), g ? s.lineTo(h, p) : s.moveTo(h, p), x ? s.lineTo(h, d) : s.moveTo(h, d), $ ? s.lineTo(u, d) : s.moveTo(u, d), s.stroke())) } function L(i, e, o, n) { var r = i.fill; if (!r) return null; if (i.fillColor) return U(i.fillColor, o, n, e); var l = t.color.parse(e); return l.a = "number" == typeof r ? r : .4, l.normalize(), l.toString() } v.setData = k, v.setupGrid = z, v.draw = A, v.getPlaceholder = function () { return i }, v.getCanvas = function () { return c.element }, v.getPlotOffset = function () { return x }, v.width = function () { return g }, v.height = function () { return $ }, v.offset = function () { var t = u.offset(); return t.left += x.left, t.top += x.top, t }, v.getData = function () { return a }, v.getAxes = function () { var i = {}; return t.each(p.concat(m), function (t, e) { e && (i[e.direction + (1 != e.n ? e.n : "") + "axis"] = e) }), i }, v.getXAxes = function () { return p }, v.getYAxes = function () { return m }, v.c2p = C, v.p2c = function t(i) { var e, o, n, r = {}; for (e = 0; e < p.length; ++e)if ((o = p[e]) && o.used && (null == i[n = "x" + o.n] && 1 == o.n && (n = "x"), null != i[n])) { r.left = o.p2c(i[n]); break } for (e = 0; e < m.length; ++e)if ((o = m[e]) && o.used && (null == i[n = "y" + o.n] && 1 == o.n && (n = "y"), null != i[n])) { r.top = o.p2c(i[n]); break } return r }, v.getOptions = function () { return s }, v.highlight = G, v.unhighlight = V, v.triggerRedrawOverlay = E, v.pointOffset = function (t) { return { left: parseInt(p[y(t, "x") - 1].p2c(+t.x) + x.left, 10), top: parseInt(m[y(t, "y") - 1].p2c(+t.y) + x.top, 10) } }, v.shutdown = S, v.destroy = function () { S(), i.removeData("plot").empty(), a = [], s = null, c = null, f = null, u = null, h = null, d = null, p = [], m = [], b = null, O = [], v = null }, v.resize = function () { var t = i.width(), e = i.height(); c.resize(t, e), f.resize(t, e) }, v.hooks = b, function i() { for (var o = { Canvas: e }, n = 0; n < r.length; ++n) { var l = r[n]; l.init(v, o), l.options && t.extend(!0, s, l.options) } }(v), function e(o) { t.extend(!0, s, o), o && o.colors && (s.colors = o.colors), null == s.xaxis.color && (s.xaxis.color = t.color.parse(s.grid.color).scale("a", .22).toString()), null == s.yaxis.color && (s.yaxis.color = t.color.parse(s.grid.color).scale("a", .22).toString()), null == s.xaxis.tickColor && (s.xaxis.tickColor = s.grid.tickColor || s.xaxis.color), null == s.yaxis.tickColor && (s.yaxis.tickColor = s.grid.tickColor || s.yaxis.color), null == s.grid.borderColor && (s.grid.borderColor = s.grid.color), null == s.grid.tickColor && (s.grid.tickColor = t.color.parse(s.grid.color).scale("a", .22).toString()); var n, r, l, a = i.css("font-size"), c = a ? +a.replace("px", "") : 13, f = { style: i.css("font-style"), size: Math.round(.8 * c), variant: i.css("font-variant"), weight: i.css("font-weight"), family: i.css("font-family") }; for (n = 0, l = s.xaxes.length || 1; n < l; ++n)(r = s.xaxes[n]) && !r.tickColor && (r.tickColor = r.color), r = t.extend(!0, {}, s.xaxis, r), s.xaxes[n] = r, r.font && (r.font = t.extend({}, f, r.font), r.font.color || (r.font.color = r.color), r.font.lineHeight || (r.font.lineHeight = Math.round(1.15 * r.font.size))); for (n = 0, l = s.yaxes.length || 1; n < l; ++n)(r = s.yaxes[n]) && !r.tickColor && (r.tickColor = r.color), r = t.extend(!0, {}, s.yaxis, r), s.yaxes[n] = r, r.font && (r.font = t.extend({}, f, r.font), r.font.color || (r.font.color = r.color), r.font.lineHeight || (r.font.lineHeight = Math.round(1.15 * r.font.size))); for (s.xaxis.noTicks && null == s.xaxis.ticks && (s.xaxis.ticks = s.xaxis.noTicks), s.yaxis.noTicks && null == s.yaxis.ticks && (s.yaxis.ticks = s.yaxis.noTicks), s.x2axis && (s.xaxes[1] = t.extend(!0, {}, s.xaxis, s.x2axis), s.xaxes[1].position = "top", null == s.x2axis.min && (s.xaxes[1].min = null), null == s.x2axis.max && (s.xaxes[1].max = null)), s.y2axis && (s.yaxes[1] = t.extend(!0, {}, s.yaxis, s.y2axis), s.yaxes[1].position = "right", null == s.y2axis.min && (s.yaxes[1].min = null), null == s.y2axis.max && (s.yaxes[1].max = null)), s.grid.coloredAreas && (s.grid.markings = s.grid.coloredAreas), s.grid.coloredAreasColor && (s.grid.markingsColor = s.grid.coloredAreasColor), s.lines && t.extend(!0, s.series.lines, s.lines), s.points && t.extend(!0, s.series.points, s.points), s.bars && t.extend(!0, s.series.bars, s.bars), null != s.shadowSize && (s.series.shadowSize = s.shadowSize), null != s.highlightColor && (s.series.highlightColor = s.highlightColor), n = 0; n < s.xaxes.length; ++n)T(p, n + 1).options = s.xaxes[n]; for (n = 0; n < s.yaxes.length; ++n)T(m, n + 1).options = s.yaxes[n]; for (var u in b) s.hooks[u] && s.hooks[u].length && (b[u] = b[u].concat(s.hooks[u])); _(b.processOptions, [s]) }(n), i.css("padding", 0).children().filter(function () { return !t(this).hasClass("flot-overlay") && !t(this).hasClass("flot-base") }).remove(), "static" == i.css("position") && i.css("position", "relative"), c = new e("flot-base", i), f = new e("flot-overlay", i), h = c.context, d = f.context, u = t(f.element).unbind(), (l = i.data("plot")) && (l.shutdown(), f.clear()), i.data("plot", v), k(o), z(), A(), s.grid.hoverable && (u.mousemove(H), u.bind("mouseleave", M)), s.grid.clickable && u.click(j), _(b.bindEvents, [u]); var O = [], R = null; function H(t) { s.grid.hoverable && B("plothover", t, function (t) { return !1 != t.hoverable }) } function M(t) { s.grid.hoverable && B("plothover", t, function (t) { return !1 }) } function j(t) { B("plotclick", t, function (t) { return !1 != t.clickable }) } function B(t, e, o) { var n = u.offset(), r = e.pageX - n.left - x.left, l = e.pageY - n.top - x.top, c = C({ left: r, top: l }); c.pageX = e.pageX, c.pageY = e.pageY; var f = function t(i, e, o) { var n, r, l, c = s.grid.mouseActiveRadius, f = c * c + 1, u = null; for (n = a.length - 1; n >= 0; --n)if (o(a[n])) { var h, d, p = a[n], m = p.xaxis, x = p.yaxis, g = p.datapoints.points, $ = m.c2p(i), b = x.c2p(e), v = c / m.scale, _ = c / x.scale; if (l = p.datapoints.pointsize, m.options.inverseTransform && (v = Number.MAX_VALUE), x.options.inverseTransform && (_ = Number.MAX_VALUE), p.lines.show || p.points.show) for (r = 0; r < g.length; r += l) { var k = g[r], y = g[r + 1]; if (null != k && !(k - $ > v) && !(k - $ < -v) && !(y - b > _) && !(y - b < -_)) { var w = Math.abs(m.p2c(k) - i), C = Math.abs(x.p2c(y) - e), T = w * w + C * C; T < f && (f = T, u = [n, r / l]) } } if (p.bars.show && !u) { switch (p.bars.align) { case "left": h = 0; break; case "right": h = -p.bars.barWidth; break; default: h = -p.bars.barWidth / 2 }for (r = 0, d = h + p.bars.barWidth; r < g.length; r += l) { var k = g[r], y = g[r + 1], S = g[r + 2]; null != k && (a[n].bars.horizontal ? $ <= Math.max(S, k) && $ >= Math.min(S, k) && b >= y + h && b <= y + d : $ >= k + h && $ <= k + d && b >= Math.min(S, y) && b <= Math.max(S, y)) && (u = [n, r / l]) } } } return u ? (n = u[0], r = u[1], l = a[n].datapoints.pointsize, { datapoint: a[n].datapoints.points.slice(r * l, (r + 1) * l), dataIndex: r, series: a[n], seriesIndex: n }) : null }(r, l, o); if (f && (f.pageX = parseInt(f.series.xaxis.p2c(f.datapoint[0]) + n.left + x.left, 10), f.pageY = parseInt(f.series.yaxis.p2c(f.datapoint[1]) + n.top + x.top, 10)), s.grid.autoHighlight) { for (var h = 0; h < O.length; ++h) { var d = O[h]; d.auto != t || f && d.series == f.series && d.point[0] == f.datapoint[0] && d.point[1] == f.datapoint[1] || V(d.series, d.point) } f && G(f.series, f.datapoint, t) } i.trigger(t, [c, f]) } function E() { var t = s.interaction.redrawOverlayInterval; if (-1 == t) { N(); return } R || (R = setTimeout(N, t)) } function N() { var t, i; for (R = null, d.save(), f.clear(), d.translate(x.left, x.top), t = 0; t < O.length; ++t)(i = O[t]).series.bars.show ? q(i.series, i.point) : Y(i.series, i.point); d.restore(), _(b.drawOverlay, [d]) } function G(t, i, e) { if ("number" == typeof t && (t = a[t]), "number" == typeof i) { var o = t.datapoints.pointsize; i = t.datapoints.points.slice(o * i, o * (i + 1)) } var n = X(t, i); -1 == n ? (O.push({ series: t, point: i, auto: e }), E()) : e || (O[n].auto = !1) } function V(t, i) { if (null == t && null == i) { O = [], E(); return } if ("number" == typeof t && (t = a[t]), "number" == typeof i) { var e = t.datapoints.pointsize; i = t.datapoints.points.slice(e * i, e * (i + 1)) } var o = X(t, i); -1 != o && (O.splice(o, 1), E()) } function X(t, i) { for (var e = 0; e < O.length; ++e) { var o = O[e]; if (o.series == t && o.point[0] == i[0] && o.point[1] == i[1]) return e } return -1 } function Y(i, e) { var o = e[0], n = e[1], r = i.xaxis, l = i.yaxis, a = "string" == typeof i.highlightColor ? i.highlightColor : t.color.parse(i.color).scale("a", .5).toString(); if (!(o < r.min) && !(o > r.max) && !(n < l.min) && !(n > l.max)) { var s = i.points.radius + i.points.lineWidth / 2; d.lineWidth = s, d.strokeStyle = a; var c = 1.5 * s; o = r.p2c(o), n = l.p2c(n), d.beginPath(), "circle" == i.points.symbol ? d.arc(o, n, c, 0, 2 * Math.PI, !1) : i.points.symbol(d, o, n, c, !1), d.closePath(), d.stroke() } } function q(i, e) { var o, n = "string" == typeof i.highlightColor ? i.highlightColor : t.color.parse(i.color).scale("a", .5).toString(), r = n; switch (i.bars.align) { case "left": o = 0; break; case "right": o = -i.bars.barWidth; break; default: o = -i.bars.barWidth / 2 }d.lineWidth = i.bars.lineWidth, d.strokeStyle = n, F(e[0], e[1], e[2] || 0, o, o + i.bars.barWidth, function () { return r }, i.xaxis, i.yaxis, d, i.bars.horizontal, i.bars.lineWidth) } function U(i, e, o, n) { if ("string" == typeof i) return i; for (var r = h.createLinearGradient(0, o, 0, e), l = 0, a = i.colors.length; l < a; ++l) { var s = i.colors[l]; if ("string" != typeof s) { var c = t.color.parse(n); null != s.brightness && (c = c.scale("rgb", s.brightness)), null != s.opacity && (c.a *= s.opacity), s = c.toString() } r.addColorStop(l / (a - 1), s) } return r } } t.fn.detach || (t.fn.detach = function () { return this.each(function () { this.parentNode && this.parentNode.removeChild(this) }) }), e.prototype.resize = function (t, i) { if (t <= 0 || i <= 0) throw Error("Invalid dimensions for plot, width = " + t + ", height = " + i); var e = this.element, o = this.context, n = this.pixelRatio; this.width != t && (e.width = t * n, e.style.width = t + "px", this.width = t), this.height != i && (e.height = i * n, e.style.height = i + "px", this.height = i), o.restore(), o.save(), o.scale(n, n) }, e.prototype.clear = function () { this.context.clearRect(0, 0, this.width, this.height) }, e.prototype.render = function () { var t = this._textCache; for (var e in t) if (i.call(t, e)) { var o = this.getTextLayer(e), n = t[e]; for (var r in o.hide(), n) if (i.call(n, r)) { var l = n[r]; for (var a in l) if (i.call(l, a)) { for (var s, c = l[a].positions, f = 0; s = c[f]; f++)s.active ? s.rendered || (o.append(s.element), s.rendered = !0) : (c.splice(f--, 1), s.rendered && s.element.detach()); 0 == c.length && delete l[a] } } o.show() } }, e.prototype.getTextLayer = function (i) { var e = this.text[i]; return null == e && (null == this.textContainer && (this.textContainer = t("<div class='flot-text'></div>").css({ position: "absolute", top: 0, left: 0, bottom: 0, right: 0, "font-size": "smaller", color: "#545454" }).insertAfter(this.element)), e = this.text[i] = t("<div></div>").addClass(i).css({ position: "absolute", top: 0, left: 0, bottom: 0, right: 0 }).appendTo(this.textContainer)), e }, e.prototype.getTextInfo = function (i, e, o, n, r) { var l, a, s, c; if (e = "" + e, l = "object" == typeof o ? o.style + " " + o.variant + " " + o.weight + " " + o.size + "px/" + o.lineHeight + "px " + o.family : o, null == (a = this._textCache[i]) && (a = this._textCache[i] = {}), null == (s = a[l]) && (s = a[l] = {}), null == (c = s[e])) { var f = t("<div></div>").html(e).css({ position: "absolute", "max-width": r, top: -9999 }).appendTo(this.getTextLayer(i)); "object" == typeof o ? f.css({ font: l, color: o.color }) : "string" == typeof o && f.addClass(o), c = s[e] = { width: f.outerWidth(!0), height: f.outerHeight(!0), element: f, positions: [] }, f.detach() } return c }, e.prototype.addText = function (t, i, e, o, n, r, l, a, s) { var c = this.getTextInfo(t, o, n, r, l), f = c.positions; "center" == a ? i -= c.width / 2 : "right" == a && (i -= c.width), "middle" == s ? e -= c.height / 2 : "bottom" == s && (e -= c.height); for (var u, h = 0; u = f[h]; h++)if (u.x == i && u.y == e) { u.active = !0; return } u = { active: !0, rendered: !1, element: f.length ? c.element.clone() : c.element, x: i, y: e }, f.push(u), u.element.css({ top: Math.round(e), left: Math.round(i), "text-align": a }) }, e.prototype.removeText = function (t, e, o, n, r, l) { if (null == n) { var a = this._textCache[t]; if (null != a) { for (var s in a) if (i.call(a, s)) { var c = a[s]; for (var f in c) if (i.call(c, f)) for (var u, h = c[f].positions, d = 0; u = h[d]; d++)u.active = !1 } } } else for (var u, h = this.getTextInfo(t, n, r, l).positions, d = 0; u = h[d]; d++)u.x == e && u.y == o && (u.active = !1) }, t.plot = function (i, e, n) { return new o(t(i), e, n, t.plot.plugins) }, t.plot.version = "0.8.3", t.plot.plugins = [], t.fn.plot = function (i, e) { return this.each(function () { t.plot(this, i, e) }) } }(jQuery);