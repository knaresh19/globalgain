### CI / CD Pipeline

To drive Jenkins CI/CD pipeline, every project needs following files in project root 

- **jenkinsfile** - Pipeline file 
- **pipeline.yml** - Custom configurations needed for the pipeline
- **deployit-manifest.xml** - default xldeploy manifest. By specifying configurations in pipeline.yml , more then one deployit files can be used to emmit multiple XLDeploy packages.

**Below is a list of steps is order of execution** 

|Step|Description|
| ------------ | ------------ |
|**INIT**   |   Initialize Environment, Pre-reqs setup `Initialize Sonar, JDK, NuGet, VSTest_2017, MSBuild_2015`|
|**BUILD** |   Build the project `"${nuget}" restore -ConfigFile ${steps.env.NUGET_SETTINGS} -Verbosity normal -NoCache -DisableParallel && mklink /d packages "%NUGET_REPOSITORY%" && "${msbuild}" /p:DeployOnBuild=true /p:CreatePackageOnPublish=true /p:DesktopBuildPackageLocation=\"${steps.pwd()}\\${config.packagingRoot}\" /p:Configuration=Release /p:PublishProfile=\"${config.publishProfile}\" /p:TransformConfigFiles=\"True\" /p:ProjectConfigTransformFileName=\"${config.projectConfigTransformFileName}\" /p:AutoParameterizationWebConfigConnectionStrings=False && mklink /d packages "%NUGET_REPOSITORY%"`|
|**TEST** |   Perform Unit Tests `"${vstest}" "${testDll.path}" /EnableCodeCoverage /InIsolation /Logger:trx /Diag:vstest-diag.log --collect:"Code Coverage" &&"%CODE_COVERAGE%" analyze /include_skipped_functions /include_skipped_modules /output:"${finalName} `|
|**DOCUMENT** |   Generate documentation. (Javadoc etc.) `no operation`|
|**ANALYSE** |   Static quality/security scans `"${scannerHome}" begin /k:'test.sln' /d:sonar.cs.vstest.reportsPaths=TestResults/**/*.trx /d:sonar.cs.vscoveragexml.reportsPaths=TestResults/**/*.coveragexml "${msbuild}" "testPath/" "${scannerHome}" end`|
|**PACKAGING** |   Package artefact into deployable `"${nuget}" pack "${csproj.path}" -Properties Configuration=Release`|
|**PUBLISH** |   Publish artefact to binary repo (nexus,etc.) `"${nuget}" push "${nupkg.path}" -ApiKey ${steps.env.API_KEY} -ConfigFile "${steps.env.NUGET_SETTINGS}"`|
|**DEPLOY** | Publish package for release to XLDeploy. Default runs only for "release/*" branches *but can be configured via pipeline.yml*|

^^${buildenv}: `/usr/local/bin/python3 -m venv ${name}`

The pipeline steps and sequence of execution are pre-configured and may vary depending on branch names. For Example, PUBLISH step runs **only** for "master" branch. 

Pipeline is run by 2 Runners: 

**Builder** - Run all pipeline steps except "DEPLOY". Used to do basic build and integration. Builder types are automatically selected based on language type selected in pipeline.yml. A no-op builder can be used if team wishes to use fully customized pipeline steps.
 
**Provisioner** - Runs as the last step "DEPLOY" after Builder operations are complete and is used to package code generated by Builder and publish it for release. Desired provisioner can be selected by configuration in pipeline.yml (Default being XLDeploy provisioner). A no-op provisioner can be used if team wishes to use fully customized provisioning (or bypass provisioning).


The default jenkinsfile and pipeline.yml has just few lines of code as it delegates to common framework pipeline. Though the default jenkinsfile should be sufficient for most needs, there are customization available depending on technology types and certain specific needs. The customizations can be done via following ways

### 1. Adding configuration in pipeline.yml
Below example demonstrates configuration options for pipeline.yml  



	### Below configuration will 'Build' the pipeline using dotNet framework builder and 'provision' (i.e. package the resources as per XLD manifest and publish the same to XLDeploy).
	
	###Builder Configurations
	## (Mandatory) Builder used to build the pipeliene type
	pipelineType: net
	# pipeline type core / framework
    pipelineTypeVersion : framework 

	runTests: true
	runSonar: true
	
	# Publish profile to sue
	publishProfile 
	# Project configuration transform file name
	projectConfigTransformFileName  
	# If your included tests, list the projects on which the tests should be executed as per below example
	tests:
	- A
	- B	

	# If you need to upload nexus artefacts
	nexus:
	- C
	- D	
	
    # Use custom location for Packaging root
    packagingRoot: "load.engine.ear/target/"

	### Provisioner Configuration #########################
	## (Optional) Provisioner used to provision the output of builder. If key "provisioner" is not specified XLDeploy provisioner is used 
	# provisioner:  XXXXXXXXXXX

	# (Optional) Branch to run provisioner for. If not specified, only runs for "release/*" branch.
	provisionFor:
	- develop
	- master
 	- feature/migrate
	
    ## Custom versioning scheme for XLDeploy package, 
    ## If not specified Default version string is {BRANCH_NAME}.{BUILD_NUMBER}-{build time, format yyyyMMdd-HHmmss }. Word ‘release’ stripped from release/* branches, ‘/’ characters replaced by ‘-‘
    ## Example: 1.0.0-20200703-074035 
    ## Available tokens: 
    ##       PROJECT_VERSION: Default version as above
    ##       BUILD_NUMBER: Jenkins Build Number
    ##       BRANCH_NAME:   Branch being built 
    deployitVersionTemplate: '${PROJECT_VERSION}-${BUILD_NUMBER}-${BRANCH_NAME}'

    ## Publish multiple packages (if tag is not specified, provisioner looks for deployit-manifest.xml in project root)
    deployitManifests:
    - deployit-manifest-comp1.xml
    - deployit-manifest-comp2.xml
    - deployit-manifest-comp3.xml
	





### 2. Adding Custom PRE/POST hooks 
Hooks can be added to each pipeline step to allow you to execute custom jenkins pipeline code blocks before/after any pipeline steps

	## Contents of Jenkinsfile
	import com.cma.pipeline.*
	import com.cma.integration.pipeline.EventManager
	import com.cma.integration.pipeline.interfaces.IEvent
	
	Map<ActionStep, List<IEvent>> newevents = [:]
	List<IEvent> initHooks = []
	List<IEvent> deployHooks = []
	
	newevents.put(ActionStep.DEPLOY, deployHooks)
	newevents.put(ActionStep.INIT, initHooks)

	initHooks.add(new IEvent() {
		def pre(steps) {
		steps.sh "printenv"
		}
		def post(steps) {
		}
	})
	
	deployHooks.add(new IEvent() {
		def pre(steps) {
		 }

		// After deployment step, build downstream job BOOKING_API_DEPLOYMENT_PUBLISH by supplying required parameters
		def post(steps) {
			def version = steps.env.PROJECT_VERSION
			def image = steps.env.PIPELINE_PROJECT_NAME
			def uppercase_project_name=steps.env.PIPELINE_PROJECT_NAME.toUpperCase()
			steps.build(job: "LARA_MOD/IBOOK/DEPLOYMENTS/BOOKING_API_DEPLOYMENT_PUBLISH/master", parameters: [
				[$class: 'ImageChoiceParameterValue', name: 'image', environment: 	'DEV2', image: image,version: version] ])
			}
	})

	@Library("cmacgm_functions@master") _
	def thisstep = this
	pipeline_processor {
  	  steps = thisstep
	    events = newevents
	}


Please refer document [CMA_CI_CD_v****.doc](https://cmacgmgroup.sharepoint.com/:f:/s/CMA-ITQualityConformity/EsOrY0gY9D9Hm4yRIrgKc-4B90V9e5f4ASfzT8q74EPSBw) for more details.
